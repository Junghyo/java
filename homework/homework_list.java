/*
 숙제 - A14_0426

 인터페이스 AttackWay
 추상메서드 attack();
 RocketAttack : AttackWay를 상속받은 실제 클래스
 attack() : 로켓공격하다
 Robot클래스
 필드: AttackWay
 메서드 : showAttack(){ 
 -attack()
 메서드 setAttackWay(AttackWay attway)
*/

/* 
 # 숙제 - A16_0426
 자판기(인터페이스)
  - 추상메서드
  display(); @@@을 판매하는 자판기
  manu(); 1. @@: @@@원 2. @@: @@@원
  
  - 공통메서드
  insertCoin(입력값) @@@원이 투입되었습니다.
  choiceMenu(번호나 문자열)
  outProduct() @@@이 나옵니다. 잔액은 @@@입니다.

*/ 

/*
 # 정리 및 확인하기 - 0426
 1. 자바의 상속에 대한 설명 중 틀린 것은 무엇입니까?
 	1) 자바는 다중 상속을 허용한다.
 	2) 부모의 메소드를 자식 클래스에서 재정의 할 수 있다.
 	3) 부모의 private 접근 제한을 갖는 필드와 메서드는 상속의 대상이 아니다.
 	4) final클래스는 상속할 수 없고 final메소드는 오버라이딩 할 수 없다.
 
 2. 오버라이딩에 대한 설명으로 틀린 것은?
 	1) 부모 메서드의 시그니쳐(타입, 메소드명, 매개변수)와 동일해야 한다.
 	2) 부모 메서드보다 좁은 접근 제한자를 붙일 수 없다.(public - 부모, private - 자식)
 	3) protected 접근 제한을 갖는 메서드는 다른 패키지의 자식클래스에서 재정의 할 수 없다.
 	4) 
 
 3. final 키워드에 대한 설명으로 틀린 것은?
 	1) final클래스는 부모 클래스로 사용할 수 있다.
 	2) final필드는 값이 저장된 후에는 변경할 수 없다.
 	3) final메서드는 재정의(오버라이딩)할 수 없다.
 	4) static final필드는 상수를 말한다.
 	
 4. 인터페이스에 대한 설명으로 틀린 것은 무엇입니까?
 	1) 인터페이스는 객체 사용 설명서 역할을 한다.
 	2) 구현 클래스가 인터페이스의 추상 메서드에 대한 실제 메서드를 가지고 있지 않으며
 	   추상 클래스가 된다.
 	3) 인터페이스는 인스턴스필드를 가질 수 있다.
 	4) 구현 객체는 인터페이스 타입으로 자동 변환된다.  
 	
*/
/*
  정리 및 확인하기 0426
  1. 중첩 멤버 클래스에 대한 설명으로 틀린 것은 무엇입니까?
  	1) 인스턴스멤버클래스는 바깥 클래스의 객체가 있어야 사용될 수 있다.
  	2) 정적멤버클래스는 바깥 클래스의 객체가 없어도 사용될 수 있다.
  	3) 인스턴스멤버클래스 내부에는 바깥 클래스의 모든 필드와 메소드를 사용할 수 있다.
  	4) 정적멤버클래스 내부에는 바깥클래스의 인스턴스 필드를 사용할 수 있다.
 */

/* 사용정의 예외 클래스 숙제 0501
 1단계
 PointException : 점수가 특정 점수 이하로 되었을 때 예외 처리로 "불합격입니다"
 Exam 
 	- getPoint(임의의 점수) : 예외처리 메서드
 	- 입력받은 점수가 60점이하일 경우 예외 객체 호출 	
 Main()	
 
 2단계
 PointException
 	- 추가 메서드 : showResult()
 		- @@과목, @@점 획득, 결과는 재수강입니다
 Exam
 	- 과목명, 시험점수
 	- getPoint() : 과목과 Random next() 활용
*/

/* 정리 및 확인하기 0501
	1. 예외에 대한 설명 중 틀린 것은 무엇입니까?
		1) 예외는 사용자의 잘못된 조작, 개발자의 잘못된 코딩으로 인한 프로그램 오류를 말한다.
		2) RuntimeException의 하위 예외는 컴파일러가 에외 처리 코드를 체크하지 않는다.
		3) 예외는 try~catch블록을 사용해서 처리된다.
		4) 자바 표준 예외란 프로그램에서 처리할 수 있다.
		
	2. try~catch-finally 블록에 대한 설명 중 틀린 것은 무엇입니까?
	 	1) try{}블록에는 예외가 발생할 수 있는 코드를 작성한다.
	 	2) catch{}블록에서 return블록은 발생한 예외를 처리하는 블록이다.
	 	3) try{}블록에서 return문을 사용하면 finally{}블록은 실행되지 않는다.
	 	4) catch{}블록은 예외의 종류별로 여러개를 작성할 수 있다.
	 	
	3. throw에 대한 설명으로 틀린 것은 무엇입니까?
	 	1) 예외를 최초로 발생시키는 코드이다.
	 	2. 예외를 호출한 곳으로 떠넘기기 위해 메소드 선언부에 작성된다.
	 	3) throw로 발생된 예외는 일반적으로 생성자나 메소드 선언부에 throws로 떠넘겨진다.
	 	4) throw키워드 뒤에는 예외 객체 생성 코드가 온다.
	
	4. 다음과 같은 메소드가 있을 때 예외를 잘못 처리한 것은 무엇입니까?
	 	1) try{ method(); }catch(Exception e){}
	 	2) void method2() throws Exception{ method1{}; }
	 	3) try{ method1(); } catch( Exception e ){}catch( ClassNotFoundException e ){}
	 	4) try{ method1(); }catch( ClassNotFoundException e ){}catch( NumberFormatException e ){}
		
*/

/*
 ArrayList 확인예제   0509
 과일가게 ArrayList : sellList
 장보는 사람 ArrayList : buyList
 시나리오 
 - 사과, 바나나, 딸기, 오렌지, 수박을 팔고 있습니다. add처리
 - 장보는 사람이 사과와 딸기를 구매했습니다. remove, add처리
 - 과일가게에서 바나나를 사과로 변경헀습니다. set처리
 - 장보는 사람이 사과와 딸기를 다 먹었습니다. remove처리
 - 장보는 사람이 가지고 있는 과일이 없다면 과일가게에서 남은 과일 중 하나를 장보는 사람에게 사은품으로 주기로 했습니다.
 
*/
package homework;

public class homework_list {

}
